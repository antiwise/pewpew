/*** ProximityManager (AS3 Version) by Grant Skinner. Jan 4, 2008* Visit www.gskinner.com/blog for documentation, updates and more free code.** You may distribute and modify this class freely, provided that you leave this header intact,* and add appropriate headers to indicate your changes. Credit is appreciated in applications* that use this code, but is not required.** Please contact info@gskinner.com for more information.**	Modified by Mike Chambers.*/package com.gskinner.sprites {		import flash.utils.Dictionary;	import __AS3__.vec.Vector;	import flash.display.DisplayObject;		import com.mikechambers.pewpew.engine.gameobjects.Enemy;			public class ProximityManager	{			// public properties:		private var gridSize:uint;			// private properties:		private var positions:Dictionary;		private var cachedResults:Dictionary;			// initialization:		public function ProximityManager(gridSize:uint=25)		{			this.gridSize = gridSize;		}			// public methods:		public function getNeighbors(mc:DisplayObject):Vector.<Enemy>		{			var off:uint = gridSize*1024;			var index:uint = ((mc.x+off)/gridSize)<<11|((mc.y+off)/gridSize); // max of +/- 2^10 (1024) rows and columns.						//vector of display object			if (cachedResults[index]) { return cachedResults[index]; }						//r is vector of display objects			var r:Vector.<Enemy> = positions[index];			if (r == null)			{				r = new Vector.<Enemy>();			}						if (positions[index-2048-1]) { r = r.concat(positions[index-2048-1]); }			if (positions[index-1]) { r = r.concat(positions[index-1]); }			if (positions[index+2048-1]) { r = r.concat(positions[index+2048-1]); }						if (positions[index-2048]) { r = r.concat(positions[index-2048]); }			if (positions[index+2048]) { r = r.concat(positions[index+2048]); }						if (positions[index-2048+1]) { r = r.concat(positions[index-2048+1]); }			if (positions[index+1]) { r = r.concat(positions[index+1]); }			if (positions[index+2048+1]) { r = r.concat(positions[index+2048+1]); }						//r is a vector of display objects			cachedResults[index] = r;						return r;		}				public function refresh(enemies:Vector.<Enemy>):void		{			// calculate grid positions:			var p:Dictionary = new Dictionary();			var gs:uint = gridSize;			var off:uint = gridSize*1024;						for each(var mc:Enemy in enemies)			{				//var mc:Enemy = Enemy(o);				var index:uint = ((mc.x+off)/gridSize)<<11|((mc.y+off)/gridSize); // max of +/- 2^10 (1024) rows and columns.								if (p[index] == null)				{ 					var v:Vector.<Enemy> = new Vector.<Enemy>();					v.push(mc);					p[index] = v; 					continue;				}								p[index].push(mc);			}			cachedResults = new Dictionary();			positions = p;		}	}}