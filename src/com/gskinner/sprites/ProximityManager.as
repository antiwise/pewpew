/*** ProximityManager (AS3 Version) by Grant Skinner. Jan 4, 2008* Visit www.gskinner.com/blog for documentation, updates and more free code.** You may distribute and modify this class freely, provided that you leave this header intact,* and add appropriate headers to indicate your changes. Credit is appreciated in applications* that use this code, but is not required.** Please contact info@gskinner.com for more information.*/package com.gskinner.sprites {		import flash.utils.Dictionary;	import flash.display.DisplayObject;	import __AS3__.vec.Vector;		public class ProximityManager {			// public properties:		public var gridSize:uint;			// private properties:		private var displayObjects:Dictionary;		private var positions:Dictionary;		private var cachedResults:Dictionary;			// initialization:		public function ProximityManager(gridSize:uint=25) {			this.gridSize = gridSize;			displayObjects = new Dictionary(true);			positions = new Dictionary();			cachedResults = new Dictionary();					}			// public methods:		public function getNeighbors(mc:DisplayObject):Vector.<DisplayObject>		{			var off:uint = gridSize*1024;			var index:uint = ((mc.x+off)/gridSize)<<11|((mc.y+off)/gridSize); // max of +/- 2^10 (1024) rows and columns.						//vector of display object			if (cachedResults[index]) { return cachedResults[index]; }						var p:Dictionary = positions;						//r is vector of display objects			var r:Vector.<DisplayObject> = p[index];			if (r == null) { r = new Vector.<DisplayObject>(); }						if (p[index-2048-1]) { r = r.concat(p[index-2048-1]); }			if (p[index-1]) { r = r.concat(p[index-1]); }			if (p[index+2048-1]) { r = r.concat(p[index+2048-1]); }						if (p[index-2048]) { r = r.concat(p[index-2048]); }			if (p[index+2048]) { r = r.concat(p[index+2048]); }						if (p[index-2048+1]) { r = r.concat(p[index-2048+1]); }			if (p[index+1]) { r = r.concat(p[index+1]); }			if (p[index+2048+1]) { r = r.concat(p[index+2048+1]); }						//r is a vector of display objects			cachedResults[index] = r;						return r;		}				public function addItem(mc:DisplayObject):void {			displayObjects[mc] = -1;		}				public function removeItem(mc:DisplayObject):void {			delete(displayObjects[mc]);		}				public function refresh():void		{			// calculate grid positions:			var m:Dictionary = displayObjects;			var p:Dictionary = new Dictionary();			var gs:uint = gridSize;			var off:uint = gridSize*1024;						for (var o:Object in m)			{				var mc:DisplayObject = DisplayObject(o);				var index:uint = ((mc.x+off)/gridSize)<<11|((mc.y+off)/gridSize); // max of +/- 2^10 (1024) rows and columns.								if (p[index] == null)				{ 					var v:Vector.<DisplayObject> = new Vector.<DisplayObject>();					v.push(mc);					p[index] = v; 					continue;				}								p[index].push(mc);			}			cachedResults = new Dictionary();			positions = p;		}	}}